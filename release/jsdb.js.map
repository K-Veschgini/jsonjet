{
  "version": 3,
  "sources": ["../src/core/operator.js", "../src/core/stream.js", "../src/operators/scan.js", "../main.js"],
  "sourcesContent": [
    "export class Operator {\n    constructor() {\n        this.downstream = null;\n        this.stream = null; // Will be set by Stream when piped\n    }\n    \n    async process(doc) {\n        throw new Error('Must implement process method');\n    }\n    \n    push(doc) {\n        // Process async but don't await - fire and forget\n        this.process(doc).then(() => {\n            // Decrement pending count when this operator finishes processing\n            if (this.stream) {\n                this.stream.pendingCount--;\n                if (this.stream.pendingCount === 0 && this.stream.finishResolve) {\n                    this.stream.finishResolve();\n                    this.stream.finishResolve = null;\n                }\n            }\n        }).catch(error => {\n            console.error('Error in operator processing:', error);\n            // Still decrement on error to avoid hanging\n            if (this.stream) {\n                this.stream.pendingCount--;\n                if (this.stream.pendingCount === 0 && this.stream.finishResolve) {\n                    this.stream.finishResolve();\n                    this.stream.finishResolve = null;\n                }\n            }\n        });\n    }\n    \n    emit(doc) {\n        if (this.downstream) {\n            this.downstream.push(doc);\n        }\n    }\n    \n    pipe(operator) {\n        this.downstream = operator;\n        return operator;\n    }\n} ",
    "import { Operator } from './operator.js';\n\nexport class Stream {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.pendingCount = 0;\n        this.finishPromise = null;\n        this.finishResolve = null;\n    }\n    \n    pipe(operator) {\n        // Set stream reference so operator can track completion\n        operator.stream = this;\n        \n        if (!this.head) {\n            this.head = this.tail = operator;\n        } else {\n            this.tail.pipe(operator);\n            this.tail = operator;\n        }\n        return this;\n    }\n    \n    push(doc) {\n        if (this.head) {\n            this.pendingCount++;\n            this.head.push(doc);\n        }\n    }\n    \n    collect(callback) {\n        const collector = new (class extends Operator {\n            async process(doc) {\n                callback(doc);\n            }\n        })();\n        \n        return this.pipe(collector);\n    }\n    \n    async finish() {\n        // If no pending operations, resolve immediately\n        if (this.pendingCount === 0) {\n            return Promise.resolve();\n        }\n        \n        // Create promise that resolves when all operations complete\n        if (!this.finishPromise) {\n            this.finishPromise = new Promise(resolve => {\n                this.finishResolve = resolve;\n            });\n        }\n        \n        return this.finishPromise;\n    }\n} ",
    "import { Operator } from '../core/operator.js';\n\nexport class ScanOperator extends Operator {\n    constructor() {\n        super();\n        this.steps = [];\n        this.stepStates = {};\n        this.nextMatchId = 0;\n    }\n\n    addStep(name, condition, assignment = null) {\n        this.steps.push({ name, condition, assignment });\n        this.stepStates[name] = null;\n        return this;\n    }\n\n    async process(doc) {\n        for (let i = this.steps.length - 1; i >= 0; i--) {\n            const step = this.steps[i];\n            let matched = false;\n            \n            // Check 1: Previous step state promotion\n            if (i > 0 && this.stepStates[this.steps[i - 1].name] !== null) {\n                const conditionMet = step.condition(this.stepStates[this.steps[i - 1].name], doc);\n                \n                if (conditionMet) {\n                    // Promote previous step's state to current step\n                    const promotedState = this.stepStates[this.steps[i - 1].name];\n                    this.stepStates[step.name] = {\n                        ...promotedState,\n                        [step.name]: { \n                            ...(promotedState[step.name] || {}),\n                            ...doc \n                        }\n                    };\n                    this.stepStates[this.steps[i - 1].name] = null;\n\n                    // Calculate assignments if assignment function exists\n                    const assignments = step.assignment ? \n                        step.assignment(this.stepStates[step.name], doc) : null;\n\n                    // Add to output (only if assignments exist)\n                    if (assignments) {\n                        this.emit(assignments);\n                    }\n                    matched = true;\n                }\n            }\n            \n            // Check 2: Current step state update (skip if Check 1 matched)\n            if (!matched && (this.stepStates[step.name] !== null || i === 0)) {\n                const conditionMet = step.condition(this.stepStates[step.name], doc);\n                \n                if (conditionMet) {\n                    // Initialize state for first step if null\n                    if (i === 0 && this.stepStates[step.name] === null) {\n                        this.stepStates[step.name] = { \n                            matchId: this.nextMatchId++,\n                            [step.name]: { ...doc }\n                        };\n                    } else if (this.stepStates[step.name] !== null) {\n                        // Update existing state - preserve accumulated properties, update document\n                        const currentState = this.stepStates[step.name];\n                        this.stepStates[step.name] = { \n                            ...currentState,\n                            [step.name]: { \n                                ...currentState[step.name],\n                                ...doc \n                            }\n                        };\n                    }\n                    \n                    // Calculate assignments if assignment function exists\n                    const assignments = step.assignment ? \n                        step.assignment(this.stepStates[step.name], doc) : null;\n\n                    // Add to output (only if assignments exist)\n                    if (assignments) {\n                        this.emit(assignments);\n                    }\n                }\n            }\n        }\n    }\n} ",
    "import { Stream } from './src/core/stream.js';\nimport { ScanOperator } from './src/operators/scan.js';\n\nasync function main() {\n    const Events = [\n        { Ts: 0, Event: \"A\" }, \n        { Ts: 1, Event: \"A\" }, \n        { Ts: 2, Event: \"B\" }, \n        { Ts: 3, Event: \"D\" },\n        { Ts: 32, Event: \"B\" }, \n        { Ts: 36, Event: \"C\" }, \n        { Ts: 38, Event: \"D\" }, \n        { Ts: 41, Event: \"E\" }, \n        { Ts: 75, Event: \"A\" }\n    ];\n\n    const scanner = new ScanOperator()\n        .addStep('inSession',\n            (state, row) => true,\n            (state, row) => {\n                state.inSession.sessionStart = state.inSession.sessionStart === null || state.inSession.sessionStart === undefined ? row.Ts : state.inSession.sessionStart;\n                return {\n                    sessionStart: state.inSession.sessionStart, \n                    session_id: state.matchId\n                };\n            }\n        )\n        .addStep('endSession', \n            (state, row) => row.Ts - state.inSession.sessionStart > 30\n        );\n\n    const pipeline = new Stream()\n        .pipe(scanner)\n        .collect(result => console.log(JSON.stringify(result)));\n\n    Events.forEach(row => pipeline.push(row));\n    \n    // Wait for all processing to complete\n    await pipeline.finish();\n    console.log('âœ… All processing complete!');\n}\n\nmain().catch(console.error); "
  ],
  "mappings": "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",
  "debugId": "877E2E194CCB0C5F64756E2164756E21",
  "names": []
}