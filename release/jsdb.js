class I{constructor(){this.downstream=null,this.stream=null}async process(q){throw new Error("Must implement process method")}push(q){this.process(q).then(()=>{if(this.stream){if(this.stream.pendingCount--,this.stream.pendingCount===0&&this.stream.finishResolve)this.stream.finishResolve(),this.stream.finishResolve=null}}).catch((B)=>{if(console.error("Error in operator processing:",B),this.stream){if(this.stream.pendingCount--,this.stream.pendingCount===0&&this.stream.finishResolve)this.stream.finishResolve(),this.stream.finishResolve=null}})}emit(q){if(this.downstream)this.downstream.push(q)}pipe(q){return this.downstream=q,q}}class J{constructor(){this.head=null,this.tail=null,this.pendingCount=0,this.finishPromise=null,this.finishResolve=null}pipe(q){if(q.stream=this,!this.head)this.head=this.tail=q;else this.tail.pipe(q),this.tail=q;return this}push(q){if(this.head)this.pendingCount++,this.head.push(q)}collect(q){let B=new class extends I{async process(z){q(z)}};return this.pipe(B)}async finish(){if(this.pendingCount===0)return Promise.resolve();if(!this.finishPromise)this.finishPromise=new Promise((q)=>{this.finishResolve=q});return this.finishPromise}}class K extends I{constructor(){super();this.steps=[],this.stepStates={},this.nextMatchId=0}addStep(q,B,z=null){return this.steps.push({name:q,condition:B,assignment:z}),this.stepStates[q]=null,this}async process(q){for(let B=this.steps.length-1;B>=0;B--){let z=this.steps[B],D=!1;if(B>0&&this.stepStates[this.steps[B-1].name]!==null){if(z.condition(this.stepStates[this.steps[B-1].name],q)){let G=this.stepStates[this.steps[B-1].name];this.stepStates[z.name]={...G,[z.name]:{...G[z.name]||{},...q}},this.stepStates[this.steps[B-1].name]=null;let H=z.assignment?z.assignment(this.stepStates[z.name],q):null;if(H)this.emit(H);D=!0}}if(!D&&(this.stepStates[z.name]!==null||B===0)){if(z.condition(this.stepStates[z.name],q)){if(B===0&&this.stepStates[z.name]===null)this.stepStates[z.name]={matchId:this.nextMatchId++,[z.name]:{...q}};else if(this.stepStates[z.name]!==null){let H=this.stepStates[z.name];this.stepStates[z.name]={...H,[z.name]:{...H[z.name],...q}}}let G=z.assignment?z.assignment(this.stepStates[z.name],q):null;if(G)this.emit(G)}}}}}async function L(){let q=[{Ts:0,Event:"A"},{Ts:1,Event:"A"},{Ts:2,Event:"B"},{Ts:3,Event:"D"},{Ts:32,Event:"B"},{Ts:36,Event:"C"},{Ts:38,Event:"D"},{Ts:41,Event:"E"},{Ts:75,Event:"A"}],B=new K().addStep("inSession",(D,F)=>!0,(D,F)=>{return D.inSession.sessionStart=D.inSession.sessionStart===null||D.inSession.sessionStart===void 0?F.Ts:D.inSession.sessionStart,{sessionStart:D.inSession.sessionStart,session_id:D.matchId}}).addStep("endSession",(D,F)=>F.Ts-D.inSession.sessionStart>30),z=new J().pipe(B).collect((D)=>console.log(JSON.stringify(D)));q.forEach((D)=>z.push(D)),await z.finish(),console.log("âœ… All processing complete!")}L().catch(console.error);

//# debugId=877E2E194CCB0C5F64756E2164756E21
